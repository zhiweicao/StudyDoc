# MIT6.824

## 分布式系统介绍

### 分布式系统的目的

- parallelism：并行
  - 并行管理大量CPU和内存，存储信息等。
- fault tolerance：容错
  - 数据备份，允许单机硬件失败后，系统仍然可用
- physical location: 物理分布
  - 不同服务器之间坐落在不同地方，例如：不同银行有不同的服务器
- security/ isolate：机器之间隔离
  - 分布式系统的复杂在于机器多之后，在不同的网络环境下会出现意想不到的故障。除此以外，机器也会出现故障。

### 分布式系统的目的

对内，通过添加更多机器的方式，提升系统的性能（吞吐量，计算力）

对外，提供统一的接口，使其使用起来和单机

### 分布式系统的特性

1. 提供可扩展性（scalability）

   - 通过加机器的方式提供性能

2. 提供容错性（Fault-Tolerance）

   1. 提供可用性
      - 在大规模计算机集群中，每天有机器出现问题，是必然的。
   2. 提供鲁棒性
      - 可以在出现错误时，提供恢复能力

   ##### 解决方式：

   1. 数据持久化(NV storage)
   2. 副本(Replication)

3. 提供一致性（consistency）

   **解决方法：**

   - 强一致性

   - 弱一致性

   - ##### 为什么有了强一致性还需要考虑弱一致性？

     - ##### 实现强一致性的成本高。需要昂贵的储存和传输成本

#### 为什么我们要使用分布式系统？

###   MapReduce

#### MapReduce的目的

提供一个分布式的框架，允许不熟悉分布式的程序员，在不考虑分布式系统的细节（比如，如何将任务分配到集群中，如何储存这些结果），只通过编写Map函数，就能从计算机的集群中计算出函数结果。

#### MapReduce的两个步骤

##### Map

每个Input都是一个file之类的数据信息

通过计算

##### Reduce

#### 一个wordCount的例子

```mermaid
graph LR
	subgraph map
    A(input) --> a(Map) --> a1('1'=1)
    a --> a2('2'=2)
    B(input) --> b(Map) --> b1('1'=0)
    b --> b2('2'=3)
    C(input) --> c(Map) --> c1('1'=4)
    c --> c2('2'=5)
   end
   subgraph reduce
    a1 --> r1(reduce)
    b1 --> r1
    c1 --> r1
    a2 --> r2(reduce)
    b2 --> r2(reduce)
    c2 --> r2(reduce)

   end
```

# COMP90020

## 全局时钟与逻辑时钟

### 全局时钟（global clock）

##### 什么是全局时钟?

全局时钟的概念来自于现实世界的时间。在分布式系统中，使用同一个时钟去执行任务。

##### 实现全局时钟有哪些困难？

在分布式系统中，实现多个设备使用统一的全局时钟是不太可能的。有以下原因：

1. 计算机设备的时间会由于各种原因，增长过快或者过慢，或者由于关机停止。
2. 数据包在计算机网络中的传输时间是不可测量的，无法从一个时间服务器精准的获取到正确的时间，只能通过发收的总体时间来预估，回程数据包的传输时间，最终结果总有误差。
3. 哪怕使用一个时间服务器来同步时间，仍然有出现单点失败的可能。
4. 由于计算机网络是不可靠的，因此，时间同步时，数据包在路上的花销总有偏差，无法获取到精确时间。
5. 由于不同计时设备自身的问题，时间的流逝并不精准，在任务执行时，最多只能保证任务执行的时间区间的正确性。

#### 时间同步的算法

##### 在同步系统中内部同步的算法（Internal synchronization of synchronous system）

##### 在异步系统中内部同步的算法（Internal synchronization of asynchronous systems）

###### Berkeley Algorithm

在集群中，刨除异常值（outlier），使用多个机器的平均值作为设备的时钟

##### 在异步系统中外部同步的算法（External synchronization of asynchronous systems）

######  Cristian's Method

使用服务器时间➕数据往返时间的平均值，同步本机的时钟。

###  逻辑时钟

##### 什么是逻辑时钟？

逻辑时钟是指，在分布式系统中，任务的执行是逻辑顺序的。具有依赖关系的任务，必须执行完当前任务后，才能执行下一个任务。

##### 为什么使用逻辑时钟？

在很多情况下，时钟的目的是用来定位任务执行的先后顺序。将这个概念抽象化后，如果有一个系统能够在分布式系统中提供任务执行的逻辑顺序。那么，这个系统也可以用来代替时钟。

##### 为什么逻辑时钟好于全局时钟？

逻辑时钟可以保证任务执行的先后顺序，而全局时钟则不能保证。

###### 为什么全局时钟不能保证任务执行的先后顺序？

因为全局时钟是周期性同步的，而且每个机器维护自己的计时系统。在任务执行的瞬间，全局时钟无法保证在分布式系统中的两个任务是按顺序执行的。

##### Happened-Before Relation

###### Definition (happened-before, ➝ )

Let a, b, c be three events. Then, the following global happenedbefore orders hold:

- HB1: If ∃ process p: a ➝ p b, then a ➝ b 
- HB2: For any message m: a = send(m) ➝ b = receive(m)
- HB3: If a ➝ b and b ➝ c, then a ➝ c

##### Lamport逻辑时钟（Lamport's Logical Clocks）

对于在每个进程中的逻辑时钟，它们都支持以下原则

1. 在初始阶段，逻辑时钟的值为0
2. LC1：
   - 每当执行一个事件后，进程的逻辑时钟+1
3. LC2：
   - 如果事件信息被进程发送，那么这个事件将包含任务的逻辑时钟
   - 对于接收到的信息，接受线程会将自身的逻辑时钟设为MAX（信息携带时钟，自身时钟）的最大值。

`TODO: Lamport的思考`

##### 向量时钟（Vector Clock）

1. 每个进程维护一个针对所有进程的时钟数组V[i .. N]
2. 每当进程Pi执行一个时间后，它就会将自身的时钟数组V[i] + 1
3. 每次发送信息时，进程Pi都会携带自身的一整个时钟数组
4. 当一个进程接收到一个信息时，它会将该信息的对应线程的时钟数组中与自身的时钟数组比较，并将所有位置的值设为其中的最大值。

###### 向量时钟的比较规则

1. **V = V’**   iff V [j] = V’ [j]                for j = 1, 2, ..., N
2. **V <= V’** iff V [j] <=V’ [j]               for j = 1, 2, ..., N
3. **V < V’**   iff V <= V’ and V != V’

## 全局状态与快照 (Global States and Snapshot)

##### 为什么需要全局状态？

1. 垃圾回收
   - 只有每个进程都了解全局的状态，才能保证垃圾回收的时候，被回收的对象没有被其他进程占用
2. 死锁问题
   - 当进程P1和进程P2都需要对方的锁时，全局状态机制可以是他们了解到现在的状态为死锁
3. 终止问题
   - 只有进程了解到全局状态，才知道任务是否成功终止。
4. 提供分布式Debug能力

##### 为什么需要快照？

1. 在系统故障时，可以通过全局快照快速恢复

##### 快照的难点

在分布式系统中，信息的传播需要时间，而且没有一个统一的时钟。因此，不可能将系统发生一瞬间的所有状态记录下来。

##### 快照的重点

快照的重点是记录下一个满足事件**执行顺序**的状态，相当于在逻辑时钟中的一个瞬间快照。

### Cut分割

##### 连贯的分割（consistent cut）和不连贯的分割（inconsistent cut）

<img src="/Users/zhiwei/Java/Doc/img/分布式分割.png" alt="image-20210404175445135" style="zoom:50%;" />

**连贯的分割**是指在分割时，分割线左边的事件早于右边的事件执行

**连贯的分割**是指在分割时，存在右边的事件早于左边的事件执行

##### 为什么需要Consistent cut？

Consistent cut保证了事件执行的顺序依赖，因此能够记录的状态符合任务执行的顺序。

##### 如果cut是inconsistent 会有什么问题？

例子1:

在分布式系统中debug，假如快照是不一致的，有可能导致bug依赖的前置事件并被没有记录下来。

例子2:

以**活锁**为例，假如快照是不一致的，记录下来的瞬间可能是两个进程都不持有对方需要的锁，而且通道中也不包含进程变化的消息。假如快照是一致的，哪怕两个进程都是释放状态，一定会记录在通道中锁转换的消息。

### Chandy-Lamport Snapshot Algorithm

> [分布式快照算法: Chandy-Lamport 算法](https://zhuanlan.zhihu.com/p/53482103)

#### 前提要求

1. Channel是可靠的
2. Channel是双工的，它们的数据传输都是按照FIFO的顺序
3. 进程都不会失败
4. 进程间都是直接连接的
5. 任意一个进程都可以发起快照算法
6. 快照执行时，进程仍然正常工作

##### Chandy-Lamport算法的目的

在一个在分布式系统中，保证快照的状态是一个连贯的分割（consistent cut），获取到一个**满足逻辑时钟顺序**的全局快照。

##### Chandy-Lamport的运行逻辑

1. 发起线程
   1. 保存自身的状态（自身的快照）
   2. 发送获取其他进程状态的请求
2. 第一次接收到快照请求的进程
   1. 发送自身的状态给发起线程
   2. 将快照请求添加到后续消息中，帮助快照请求的传播
3. 当已经接到请求的线程接收到不包含请求的消息时，它将把这个消息转发给发起线程。（这么做的目的是把快照发起前，在通道中的传输的状态变化保存下来）

##### Chandy-Lamport的运行细节

那么我们基于上面假设的分布式系统模型来看一下 Chandy-Lamport 算法具体的工作流程是什么样的。主要包括下面三个部分：

- Initiating a snapshot: 也就是开始创建 snapshot，可以由系统中的任意一个进程发起
- Propagating a snapshot: 系统中其他进程开始逐个创建 snapshot 的过程
- Terminating a snapshot: 算法结束条件

**Initiating a snapshot**

1. 进程Pi记录自身的状态
2. 进程发送Marker给所有其他连接到的进程
3. 开始记录所有Channel输入的消息

**Propagating a snapshot**

###### *Marker的特性*

1. 在一个进程记录自身状态之后，它将在发送其他信息之前，把marker发送到所有对外的通道
2. Marker是用来分割快照内和快照外的消息
3. 当进程收到marker消息时，它必须首先记录自身的状态

###### *Marker的接收规则*

当进程Pi从Channel c接收到Marker信息时

- 如果之前没有接收到过
  1. 记录自身状态
  2. 将channel c的状态记录为空set（即没有任何来自Channel c的消息作为全局状态的一部分）
  3. 记录所有从其他Channel发送过来的消息
- 如果它已经接受过
  1. Pi将所有在快照开启后的信息都记录到一个set中
     - 这是为了将全局快照中，通道中的信息保留下来

###### *Marker的发送规则*

当Pi记录了自身状态后，先发送一个marker出去，然后再发送后续消息。

**Terminating a snapshot**

- 所有的进程都收到 marker 信息并且记录下自己的状态和 channel 的状态（包含的 message）

## 分布式Week4

### 同步系统（synchronized）和异步(asynchronized)系统

### 失败前提 (Failure Assumption)

- 进程通过可靠的channel连接
  - 即信息最终会被交付。在互联网中，由于极端情况（例如：断网），则可能最终不会被交付
- 进程不依赖其他进程去沟通
  - 即线程a和c不能通过线程b去沟通。
- 根据不同算法：
  - 进程不能失败
  - 进程可以crash
    - 可以使用failure detector去侦测
  - 进程可以执行异常行为

### 失败探测器（Failure Detector）

##### 什么是失败探测器？

一个服务可以探测集群中的进程是否crash

##### 常见的实施方式

在集群中的每个进程，包含一个运行失败探测算法的失败检测器

##### 失败侦测器两种形式

- 不可靠的失败探测器（unreliable Failure Detector）

  - ##### 进程的状态

    - unsuspected
      - 根据已有信息，认为该进程仍然正常运行
    - suspected
      - 通过一些机制，判定进程已经失败

  - ##### 一个实现方式：心跳包

    - 周期性的发送心跳包

    ###### 心跳包的问题

    - 可能会由于网络堵塞，导致整体服务降级。即使在这种场景下，服务仍然正常运行
    - 在心跳包的周期内，仍然不知道进程是否存活

- 可靠的失败探测器（Reliable Failure Detector）

  - ##### 进程的状态

    - Unsuspected
    - Failed
      - 确认进程已经失败

  - ##### 实现方式

    - 注：只能在同步系统中实现

### 分布式锁 

##### 分布式系统中实现锁的挑战

1. 没有共享变量
2. 没有内核调度资源
3. 需要解决信息延迟问题

##### 实现的前提

1. 只有一个临界区
2. 系统是异步的
3. 信息传输是可靠的
4. 进程不会失败

##### 独占锁的要求

1. safety，最多只有一个进程在临界区
2. liveness，尝试进入或退出临界区最终都会成功
3. ordering，执行顺序是FIFO（非必须）

##### 独占锁的算法评估方式

1. 带宽消耗
2. 客户延迟
3. 总体吞吐量

#### 分布式锁的实现方式

##### 中央服务器算法(Central server algorithm)

所有锁的获取都需要通过中心服务器

##### 环状锁(Ring-Based algorithm)

1. token向一个方向传递成环
   1. 环是逻辑上的
2. 只有持有token的进程才能够进入临界区
3. 当没有进入临界区的需求或者正在退出临界区时，将token传给邻居

##### Ricart And Agrawala's Algorithm

1. 基于逻辑时钟Lamport clock
2. 进程通过请求去进入临界区
   1. 发送全局获取锁请求，只有获取到所有进程的准许后，才能进入临界区
   2. 正在临界区中的进程或者之前申请独占锁的进程，会延迟回复获取锁的请求
3. 每个进程都有自己的ID

<img src="./img/ricart and agrawala's algorithm.png" alt="image-20210327191204767" style="zoom:67%;" />

###### 线程的三种状态

1. Release，初始阶段
2. Wanted，需要锁时，携带自身的逻辑时钟
3. Held

###### ME Condition

符合ME1，只有一个进程可以进入临界区

符合ME2，所有获取锁的进程都将进入临界区

符合ME3，获取锁的顺序是FIFIO

##### Maekawa's Voting Algorithm

1. 一个进程不需要从所有进程中获得许可，只需要在一个subset的进程中获取许可
2. 进程被分为许多组，任意两个组之间一定有交集，即一个进程存在于两个voting组中。
3. 进程只有获取到足够的投票才能进入临界区

###### Voting Set

1. 任意两个组之间一定有交集
2. 当一个进程属于某个voting set，那么他一定存在于该voting set
3. 所有的voting set大小相等，为K
4. 每个进程可以存在于K个voting set
   1. 每个voting set中，有一个进程会被选为代表投票

###### 优化的k值

K = sqrt(N)时效率最高

###### 算法细节

```
1. 初始阶段
   - state = release
   - voted = false
2. 当一个线程想要进入临界区
   - statue转化为Wanted
   - 对所有进程广播，获取permission
   - 等待K个permission
3. 当Pi收到Pj的请求时
   - 如果state = Held 或者 vote = true
     - 将请求加入队列
   - 不然则回复，并将voting设为true
4. 当Pj退出临界区时，
   - 设置state = release
   - 广播释放锁的消息
5. 当Pj收到释放请求时
   - 如果请求队列不为空
     - 将投票给头并设置voting为true
   - 否则
     - 设置voting为false
```

#### `TODO`提一些问题

## 选举算法

##### 选举算法的目的是什么？

选举算法的目的是在分布式系统中选出一个Leader节点，这个节点将会承担特殊的责任。

### Ring-Based Election

#### 基础

1. 任意一个进程都可以发起选举
2. 进程最多只能发起一个选举，选举的结果与发起的进程无关
3. 被选中的进程是唯一的
4. 可以同时有多个进程发起选举，如果两个进程同时发起选举，它们将会选出同一个leader。
5. 每个进程有一个唯一的identifier
6. 在任意一个时刻，participant代表运行选举算法的进程， non-participant代表不参与某个选举的进程。

#### Leader

